import numpy as np

def lnprior(theta, FeH_range, age_range):

    """
      This is a function representing the log-prior probability distribution of the log10 age and
    metallicity parameters (which are sampled via MCMC, and emcee's EnsembleSampler() in particular). 

    INPUT:
    =====================================================================================================

        mass_theta (float, tuple):
        ++++++++++++++++++++++++++
          A tuple of two floats representing metallicity (0th ekement) and log10 age (1st element).
        This tuple is generated by EnsembleSampler() from the emcee package, as these are two of the
        parameters with which we want to sample the posterior distribution via MCMC.   

        FeH_range (float, tuple):
        +++++++++++++++++++++++++
          The maximum and minimum metallicities available in the models.

        age_range (float, tuple):
        +++++++++++++++++++++++++
          The maximum and minimum log10 ages available in the models.
    
    OUTPUT:
    ======================================================================================================

        return (float):
        +++++++++++++++++++
          Returns the value of the prior on log10 age and metallicity for the proposed values of these
        parameters. A -infinity is returned if the proposed age or metallicity is out of the valid range
        of their values which assigns zero log-probability to that sampling. Or else a probability of 1, 
        or log-probability of zero is returned.

    """
    # Unpack theta (rotation will be added...):
    metallicity = theta[0]
    age = theta[1]

    if age_range[0] < age < age_range[1]:
        
        return FeH_lnprior(metallicity)

    return -np.inf


def primary_mass_lnprior(primary_mass, calc_log=True):
    """
    Miller & Scalo (1979) initial mass function (IMF) informed Gaussian prior on log of the primary mass.
    The IMF gives the probablity of a star with a given mass having been produced in a stellar population,
    and so its mean and variance are used here to form a probability distribution from which we test the 
    probability of the proposed initial primary mass coming from that distribution.
    (Based on the discussion in van Dyk et al. 2009.) 

    INPUT:
    =====================================================================================================

        primary_mass (float):
        ++++++++++++++++++++++++++
          The primary mass proposed by the MCMC sampler for a given star. This proposition will be tested
        repeatedly during sampling as the MCMC algorithm seeks the proposition which yields the highest
        probability of data matching the proposed model.
    
    OUTPUT:
    ======================================================================================================

        return (float):
        +++++++++++++++++++
          The returned value reprents the prior prbability (prob. of parameter, given data) of the initial
        mass parameter. If calc_log == True, then this represents the log-prior probability.      

    OPTIONS:
    ======================================================================================================

        calc_log (bool):
        +++++++++++++++++++
          Default: True

          If set to True, this option will set the returned value to be the log (base e) of the calculated
        likelihood function.

    """

    # The Gaussian prior on primary initial mass; constants derived from Miller & Scalo IMF.
    # This IMF is ~a half Gaussian distribution which peaks at around 0.1 in log stellar mass.
    # (See Table 7 in Miller & Scalo 1975.)
    
    primaryM_prior = 1.3 * np.exp( -0.5 * ((np.log10(primary_mass) + 1.02) / 0.677)**2.0 )

    if calc_log:
        return np.log(primaryM_prior)
    else:
        return primaryM_prior

def star_lnprior(star_theta, mode = 'single'):

    """
      This function represents a flat prior probability distrubtion in the range of 0 to the proposed
    primary mass (provided by the MCMC sampler). Propositions outside of this range are assigned zero
    probability. 

    INPUT:
    =====================================================================================================

        mass_theta (float, tuple):
        ++++++++++++++++++++++++++
          A tuple of two floats representing primary (0th ekement) and secondary mass (1st element).
        This tuple is generated by EnsembleSampler() from the emcee package, as these are two of the
        parameters with which we want to sample the posterior distribution via MCMC.   

            
    OUTPUT:
    ======================================================================================================

        return (float):
        +++++++++++++++++++
          The returned value represents the log-prior probability of the proposed secondary mass value. If
        the proposed value lies outside the range of greater than 0 and less than the initial primary mass,
        a value of -infinity (zero log-probability) is returned. 
         
    """

    if mode == 'single':
        if len(star_theta) == 2:
            primary_mass = star_theta[0]
            Pfield = star_theta[1]

            return primary_mass_lnprior(primary_mass)

        elif len(star_theta) == 3:
            primary_mass = star_theta[0]
            secondary_mass = star_theta[1]
            Pfield = star_theta[2]

            if 0.0 <= secondary_mass <= primary_mass and 0.0 <= Pfield <= 1.0:

                return primary_mass_lnprior(primary_mass)

    elif mode == 'all':
        if isinstance(star_theta, np.ndarray) or isinstance(star_theta, list):
            if len(star_theta) == 1:
                primary_mass = star_theta[0]
                Pfield = 0.0
        
                return primary_mass_lnprior(primary_mass)
        
            elif len(star_theta) == 2:
                primary_mass = star_theta[0]
                secondary_mass = star_theta[1]
                Pfield = 0.0
            elif len(star_theta) == 3:
                primary_mass = star_theta[0]
                secondary_mass = star_theta[1]
                Pfield = star_theta[3]
        
            if 0.0 <= secondary_mass <= primary_mass and 0.0 <= Pfield <= 1.0:
        
                return primary_mass_lnprior(primary_mass)
        
        else:
            primary_mass = star_theta
            Pfield = 0.0
         
            return primary_mass_lnprior(primary_mass)

    return -np.inf

def FeH_lnprior(metallicity, calc_log = True):

    # Gaussian metallicity prior w/ std. dev. of +/- 0.1 dex, 
    # centered on FeH = 0.0 a la Brandt 2015.
    sig = 0.1
    const_factor = 1.0 / np.sqrt(2.0 * np.pi * sig**2.0)
    FeH_prior = const_factor * np.exp( -0.5 * (metallicity/sig)**2.0 )

    if calc_log:
        return np.log(FeH_prior)
    else:
        return FeH_prior


